defmodule Helpers do
  @doc "Cross product of elements in A and elements in B."
  @spec cross([t1], [t2]) :: [[t1,t2],...]
  def cross(as, bs) do
    for a <- as, b <- bs, do: [a, b]
  end

  def merge([l1,l2,l3]), do: l1 ++ l2 ++ l3
end
  
defmodule Suduko do

  @type square_key :: [ ?A..?I, ?1..?9 ]
  @type square_content :: [ integer, ... ]
  @type grid_entry :: square_key => square_content
  @type grid       :: %{ grid_entry }
  @type reason     :: binary
  @type maybe_grid :: { :ok, grid } | { :conflict, reason }
  
  import Helpers

  ## See http://norvig.com/sudoku.html

  # A Sudoku puzzle is a grid of 81 squares; the majority of enthusiasts
  # label the columns 1-9, the rows A-I, and call a collection of nine
  # squares (column, row, or box) a unit and the squares that share a
  # unit the peers. A puzzle leaves some squares blank and fills others
  # with digits, and the whole idea is:
  
  
  ## Throughout this program we have:
  ##   r is a row,    e.g. 'A'
  ##   c is a column, e.g. '3'
  ##   s is a square, e.g. 'A3'
  ##   d is a digit,  e.g. '9'
  ##   u is a unit,   e.g. ['A1','B1','C1','D1','E1','F1','G1','H1','I1']
  ##   grid is a grid,e.g. 81 non-blank chars, e.g. starting with '.18...7...
  ##   values is a dict of possible values, e.g. {'A1':'12349', 'A2':'8', ...}



  def assign_into(grid_values, initial_grid) do
    Enum.reduce(grid_values, { :ok, grid }, &assign_into_square/2)
  end


  def assign(values, s, d) when is_integer(d) do
    assign(values, s, [d])
  end
  
  def assign(grid, s, d) do
    unless is_list(grid[s]), do: raise("s = #{s}\n#{inspect grid}") 
    all_but_d = grid[s] -- d
    Enum.reduce(all_but_d, {{:ok, grid}, s}, &eliminate_by_d/2)
    |> elem(0)
  end
  

  if false do


  def eliminate_by_s(s, {{:ok, values}, d}) when is_integer(d) and is_list(s) do
    { eliminate(values, s, d), d}
  end
  
  def eliminate_by_s(_s, other) do
    other
  end    
    


end



                # 
# def assign(values, s, d):
#     other_values = values[s].replace(d, '')
#     if all(eliminate(values, s, d2) for d2 in other_values):
#         return values
#     else:
#         return False
# 
# def eliminate(values, s, d):
#     if d not in values[s]:
#         return values ## Already eliminated
#     values[s] = values[s].replace(d,'')
#     ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.
#     if len(values[s]) == 0:
#         return False ## Contradiction: removed last value
#     elif len(values[s]) == 1:
#         d2 = values[s]
#         if not all(eliminate(values, s2, d2) for s2 in peers[s]):
#             return False
#     ## (2) If a unit u is reduced to only one place for a value d, then put it there.
#     for u in units[s]:
#         dplaces = [s for s in u if d in values[s]]
#         if len(dplaces) == 0:
#             return False ## Contradiction: no place for this value
#         elif len(dplaces) == 1:
#             # d can only be in one place in unit; assign it there
#             if not assign(values, dplaces[0], d):
#                 return False
#     return values
# 
# ################ Display as 2-D grid ################
# 
# def display(values):
#     "Display these values as a 2-D grid."
#     width = 1+max(len(values[s]) for s in squares)
#     line = '+'.join(['-'*(width*3)]*3)
#     for r in rows:
#         print ''.join(values[r+c].center(width)+('|' if c in '36' else '')
#                       for c in cols)
#         if r in 'CF': print line
#     print
# 
# ################ Search ################
# 
# def solve(grid): return search(parse_grid(grid))
# 
# def search(values):
#     "Using depth-first search and propagation, try all possible values."
#     if values is False:
#         return False ## Failed earlier
#     if all(len(values[s]) == 1 for s in squares):
#         return values ## Solved!
#     ## Chose the unfilled square s with the fewest possibilities
#     n,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
#     return some(search(assign(values.copy(), s, d))
#                 for d in values[s])
# 
# ################ Utilities ################
# 
# def some(seq):
#     "Return some element of seq that is true."
#     for e in seq:
#         if e: return e
#     return False
# 
# def from_file(filename, sep='\n'):
#     "Parse a file into a list of strings, separated by sep."
#     return file(filename).read().strip().split(sep)
# 
# def shuffled(seq):
#     "Return a randomly shuffled copy of the input sequence."
#     seq = list(seq)
#     random.shuffle(seq)
#     return seq
# 
# ################ System test ################
# 
# import time, random
# 
# def solve_all(grids, name='', showif=0.0):
#     """Attempt to solve a sequence of grids. Report results.
#     When showif is a number of seconds, display puzzles that take longer.
#     When showif is None, don't display any puzzles."""
#     def time_solve(grid):
#         start = time.clock()
#         values = solve(grid)
#         t = time.clock()-start
#         ## Display puzzles that take long enough
#         if showif is not None and t > showif:
#             display(grid_values(grid))
#             if values: display(values)
#             print '(%.2f seconds)\n' % t
#         return (t, solved(values))
#     times, results = zip(*[time_solve(grid) for grid in grids])
#     N = len(grids)
#     if N > 1:
#         print "Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs)." % (
#             sum(results), N, name, sum(times)/N, N/sum(times), max(times))
# 
# def solved(values):
#     "A puzzle is solved if each unit is a permutation of the digits 1 to 9."
#     def unitsolved(unit): return set(values[s] for s in unit) == set(digits)
#     return values is not False and all(unitsolved(unit) for unit in unitlist)
# 
# def random_puzzle(N=17):
#     """Make a random puzzle with N or more assignments. Restart on contradictions.
#     Note the resulting puzzle is not guaranteed to be solvable, but empirically
#     about 99.8% of them are solvable. Some have multiple solutions."""
#     values = dict((s, digits) for s in squares)
#     for s in shuffled(squares):
#         if not assign(values, s, random.choice(values[s])):
#             break
#         ds = [values[s] for s in squares if len(values[s]) == 1]
#         if len(ds) >= N and len(set(ds)) >= 8:
#             return ''.join(values[s] if len(values[s])==1 else '.' for s in squares)
#     return random_puzzle(N) ## Give up and make a new puzzle
# 
# grid1  = '003020600900305001001806400008102900700000008006708200002609500800203009005010300'
# grid2  = '4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......'
# hard1  = '.....6....59.....82....8....45........3........6..3.54...325..6..................'
#     
# if __name__ == '__main__':
#     test()
#     solve_all(from_file("easy50.txt", '========'), "easy", None)
#     solve_all(from_file("top95.txt"), "hard", None)
#     solve_all(from_file("hardest.txt"), "hardest", None)
#     solve_all([random_puzzle() for _ in range(99)], "random", 100.0)
# 
# ## References used:
# ## http://www.scanraid.com/BasicStrategies.htm
# ## http://www.sudokudragon.com/sudokustrategy.htm
# ## http://www.krazydad.com/blog/2005/09/29/an-index-of-sudoku-strategies/
# ## http://www2.warwick.ac.uk/fac/sci/moac/currentstudents/peter_cock/python/sudoku/  
end
